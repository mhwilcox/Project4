second words test. 
size of adjChar: 0
size of path: 1
side of stk: 0
solution at beginning of convert:: 
s1: ant s2: eat
s1: ant and s2: eat share a char at: 2

    char doesn't match at: 1 pushing to adjChar. 

    char doesn't match at: 0 pushing to adjChar. 

char that is being adjusted: 1
just before for loop: ant
	************* doesn't match char to s2 : act
	************* doesn't match char to s2 : aft
word alreay in path:  ant
   **********   
   ******   

	************* doesn't match char to s2 : apt
	************* doesn't match char to s2 : art
w==25 and no match to s2.
val: ant, curr val: act
path size: 2
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: act
word alreay in path:  act
   **********   
   ******   

w==25 and no match to s2.
val: act, curr val: aft
path size: 3
   ********   
  8888888   
 ******* 



char that is being adjusted: 1
just before for loop: aft
word alreay in path:  act
   **********   
   ******   

word alreay in path:  aft
   **********   
   ******   

word alreay in path:  ant
   **********   
   ******   

	************* doesn't match char to s2 : apt
	************* doesn't match char to s2 : art
w==25 and no match to s2.
val: aft, curr val: apt
path size: 4
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: apt
word alreay in path:  apt
   **********   
   ******   

	************* doesn't match char to s2 : opt
w==25 and no match to s2.
val: apt, curr val: art
path size: 5
   ********   
  8888888   
 ******* 



char that is being adjusted: 1
just before for loop: art
word alreay in path:  act
   **********   
   ******   

word alreay in path:  aft
   **********   
   ******   

word alreay in path:  ant
   **********   
   ******   

word alreay in path:  apt
   **********   
   ******   

word alreay in path:  art
   **********   
   ******   

w==25 and no match to s2.
val: art, curr val: ant
path size: 5
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: ant
word alreay in path:  ant
   **********   
   ******   

w==25 and no match to s2.
val: ant, curr val: act
path size: 5
   ********   
  8888888   
 ******* 



char that is being adjusted: 1
just before for loop: act
word alreay in path:  act
   **********   
   ******   

word alreay in path:  aft
   **********   
   ******   

word alreay in path:  ant
   **********   
   ******   

word alreay in path:  apt
   **********   
   ******   

word alreay in path:  art
   **********   
   ******   

w==25 and no match to s2.
val: act, curr val: apt
path size: 5
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: apt
word alreay in path:  apt
   **********   
   ******   

	************* doesn't match char to s2 : opt
w==25 and no match to s2.
val: apt, curr val: art
path size: 5
   ********   
  8888888   
 ******* 



char that is being adjusted: 1
just before for loop: art
word alreay in path:  act
   **********   
   ******   

word alreay in path:  aft
   **********   
   ******   

word alreay in path:  ant
   **********   
   ******   

word alreay in path:  apt
   **********   
   ******   

word alreay in path:  art
   **********   
   ******   

w==25 and no match to s2.
val: art, curr val: aft
path size: 5
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: aft
word alreay in path:  aft
   **********   
   ******   

	************* doesn't match char to s2 : oft
w==25 and no match to s2.
val: aft, curr val: opt
path size: 6
   ********   
  8888888   
 ******* 



char that is being adjusted: 1
just before for loop: opt
wtemp = oat	||  This is if chars match from current word to s2.
	this is path.at wtemp: opt
val: opt, curr val: apt
path size: 7
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: apt
word alreay in path:  apt
   **********   
   ******   

word alreay in path:  opt
   **********   
   ******   

w==25 and no match to s2.
val: apt, curr val: art
path size: 7
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: art
word alreay in path:  art
   **********   
   ******   

w==25 and no match to s2.
val: art, curr val: ant
path size: 7
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: ant
word alreay in path:  ant
   **********   
   ******   

w==25 and no match to s2.
val: ant, curr val: act
path size: 7
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: act
word alreay in path:  act
   **********   
   ******   

w==25 and no match to s2.
val: act, curr val: opt
path size: 7
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: opt
word alreay in path:  apt
   **********   
   ******   

word alreay in path:  opt
   **********   
   ******   

w==25 and no match to s2.
val: opt, curr val: apt
path size: 7
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: apt
word alreay in path:  apt
   **********   
   ******   

word alreay in path:  opt
   **********   
   ******   

w==25 and no match to s2.
val: apt, curr val: art
path size: 7
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: art
word alreay in path:  art
   **********   
   ******   

w==25 and no match to s2.
val: art, curr val: oft
path size: 8
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: oft
word alreay in path:  aft
   **********   
   ******   

word alreay in path:  oft
   **********   
   ******   

w==25 and no match to s2.
val: oft, curr val: aft
path size: 8
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: aft
word alreay in path:  aft
   **********   
   ******   

word alreay in path:  oft
   **********   
   ******   

w==25 and no match to s2.
val: aft, curr val: oat
path size: 8
   ********   
  8888888   
 ******* 



char that is being adjusted: 0
just before for loop: oat
	************* doesn't match char to s2 : bat
	************* doesn't match char to s2 : cat

THIS IS CORRECT!!!! wtemp: eat
&&&  this is path.at wtemp: oat
s2 acheived. break

path value: oat
trying to fix emplacemtn. wrdQueue.front(): apt and path.at(val): opt
wQ char: a and path{val} char: o  count++ 1
 this is i: 0
wQ char: p and path{val} char: p this is i: 1
wQ char: t and path{val} char: t****************************************** s2.length - 1
 this is i: 2
this is temp: eat this is what's before temp: oat and this is what's before that: opt

path value: opt
trying to fix emplacemtn. wrdQueue.front(): apt and path.at(val): aft
wQ char: a and path{val} char: a this is i: 0
wQ char: p and path{val} char: f  count++ 1
 this is i: 1
wQ char: t and path{val} char: t****************************************** s2.length - 1
 this is i: 2
this is temp: oat this is what's before temp: opt and this is what's before that: aft

path value: aft
trying to fix emplacemtn. wrdQueue.front(): apt and path.at(val): act
wQ char: a and path{val} char: a this is i: 0
wQ char: p and path{val} char: c  count++ 1
 this is i: 1
wQ char: t and path{val} char: t****************************************** s2.length - 1
 this is i: 2
this is temp: opt this is what's before temp: aft and this is what's before that: act

path value: act
trying to fix emplacemtn. wrdQueue.front(): apt and path.at(val): ant
wQ char: a and path{val} char: a this is i: 0
wQ char: p and path{val} char: n  count++ 1
 this is i: 1
wQ char: t and path{val} char: t****************************************** s2.length - 1
 this is i: 2
this is temp: aft this is what's before temp: act and this is what's before that: ant
adding to solution: aft
adding to solution: opt
adding to solution: oat
adding to solution: eat
stk size: 0

**********-------------************: ant --> aft --> opt --> oat --> eat
clearing map, queue, & stack.

return of 'ant to eat': ant --> aft --> opt --> oat --> eat
